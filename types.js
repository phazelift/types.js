"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Generated by CoffeeScript 2.5.1
(function () {
  var _LITERALS, _TYPES;

  //	types.js - A tiny and fast dynamic type checker/enforcer library
  // MIT License
  // Copyright (c) 2014 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  // heavily refactored to reduce size while optimizing for speed, at the cost of some readability..
  var ARRAY, BOOLEAN, BREAK_IF_EQUAL, DATE, DEFINED, ENUM, ENUM_ERR_PREFIX, ENUM_ID, FORCE_MSG_PREFIX, FUNCTION, LITERALS, LOGGING_DISABLED, LOGGING_ENABLED, MODULE_NAME, NAN, NULL, NUMBER, OBJECT, REGEXP, STRING, SYMBOL, TYPES, Types, UNDEFINED, createEnum, createForce, instanceOf, log, _logForce, testHasAndAll, typeOf, types, upFirst;

  MODULE_NAME = 'types.js';
  ENUM_ID = '_ENUM_';
  FORCE_MSG_PREFIX = "".concat(MODULE_NAME, " - force");
  ENUM_ERR_PREFIX = "".concat(MODULE_NAME, " - enum: ERROR,");
  LOGGING_DISABLED = "".concat(MODULE_NAME, " - all logging disabled by user");
  LOGGING_ENABLED = "".concat(MODULE_NAME, " - logging re-enabled by user");
  ARRAY = 'array';
  BOOLEAN = 'boolean';
  DATE = 'date';
  DEFINED = 'defined';
  ENUM = 'enum';
  FUNCTION = 'function';
  NAN = 'nan';
  NULL = 'null';
  NUMBER = 'number';
  OBJECT = 'object';
  REGEXP = 'regexp';
  STRING = 'string';
  SYMBOL = 'symbol';
  UNDEFINED = 'undefined';
  LITERALS = (_LITERALS = {}, _defineProperty(_LITERALS, BOOLEAN, false), _defineProperty(_LITERALS, STRING, ''), _defineProperty(_LITERALS, OBJECT, {}), _defineProperty(_LITERALS, ARRAY, []), _defineProperty(_LITERALS, FUNCTION, function () {}), _defineProperty(_LITERALS, NUMBER, function () {
    var number;
    number = new Number();
    number["void"] = true;
    return number;
  }()), _defineProperty(_LITERALS, REGEXP, new RegExp()), _LITERALS);

  log = function log() {
    if (Types.logging) {
      var _console;

      return (_console = console).log.apply(_console, arguments);
    }
  };

  _logForce = function logForce() {}; // an unsafe internal for making the first character of a type id uppercase


  upFirst = function upFirst(str) {
    return str = str[0].toUpperCase() + str.slice(1);
  };

  instanceOf = function instanceOf(type, value) {
    return value instanceof type;
  }; // type defaults to object, for internal can do, saves for a few bytes..


  typeOf = function typeOf(value) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : OBJECT;
    return _typeof(value) === type;
  };

  createEnum = function createEnum() {
    var _enum;

    _enum = {};
    Object.defineProperty(_enum, ENUM_ID, {
      configurable: false,
      enumerable: false,
      value: true,
      writable: false
    });
    return _enum;
  }; // all definitions that will be used for the is[type], not[type], etc.. tests


  TYPES = (_TYPES = {}, _defineProperty(_TYPES, UNDEFINED, function (value) {
    return value === void 0;
  }), _defineProperty(_TYPES, NULL, function (value) {
    return value === null;
  }), _defineProperty(_TYPES, FUNCTION, function (value) {
    return typeOf(value, FUNCTION);
  }), _defineProperty(_TYPES, BOOLEAN, function (value) {
    return typeOf(value, BOOLEAN);
  }), _defineProperty(_TYPES, STRING, function (value) {
    return typeOf(value, STRING);
  }), _defineProperty(_TYPES, ARRAY, function (value) {
    return typeOf(value) && instanceOf(Array, value);
  }), _defineProperty(_TYPES, REGEXP, function (value) {
    return typeOf(value) && instanceOf(RegExp, value);
  }), _defineProperty(_TYPES, DATE, function (value) {
    return typeOf(value) && instanceOf(Date, value);
  }), _defineProperty(_TYPES, NUMBER, function (value) {
    return typeOf(value, NUMBER) && value === value || typeOf(value) && instanceOf(Number, value);
  }), _defineProperty(_TYPES, OBJECT, function (value) {
    return typeOf(value) && value !== null && !instanceOf(Boolean, value) && !instanceOf(Number, value) && !instanceOf(Array, value) && !instanceOf(RegExp, value) && !instanceOf(Date, value);
  }), _defineProperty(_TYPES, SYMBOL, function (value) {
    return typeOf(value, SYMBOL);
  }), _defineProperty(_TYPES, NAN, function (value) {
    return typeOf(value, NUMBER) && value !== value;
  }), _defineProperty(_TYPES, ENUM, function (value) {
    return Types.forceObject(value).hasOwnProperty(ENUM_ID);
  }), _defineProperty(_TYPES, DEFINED, function (value) {
    return value !== void 0;
  }), _TYPES);

  TYPES.StringOrNumber = function (value) {
    return TYPES[STRING](value) || TYPES[NUMBER](value);
  }; // define the main object that this module returns


  Types = types = {
    // used by forceNumber to set the Radix, defaults to decimals
    parseIntBase: 10,
    autoConvert: true,
    logging: true,
    disableLogging: function disableLogging() {
      Types.logging = false;
      return console.log(LOGGING_DISABLED);
    },
    enableLogging: function enableLogging() {
      Types.logging = true;
      return console.log(LOGGING_ENABLED);
    },
    logForce: function logForce(externalLog) {
      return _logForce = function _logForce(errLevel, expectedType, encounteredType) {
        var msg;

        if (Types.isFunction(externalLog)) {
          return externalLog(errLevel, expectedType, encounteredType);
        } else {
          msg = expectedType;

          switch (errLevel) {
            case 1:
              msg += ": initial value is not of type " + expectedType;
              break;

            case 2:
              msg += ": optional value is not of type " + expectedType;
              break;

            case 3:
              msg += ": no valid type found, returning a type " + expectedType + " literal";
          }

          return log(FORCE_MSG_PREFIX + msg);
        }
      };
    }
  }; // factory that creates all Types.force[type] variations

  createForce = function createForce(type) {
    var Type, test;
    Type = upFirst(type); // convert value in case initial Type test failed. failed conversion returns undefined

    test = function test(value) {
      if (types.autoConvert) {
        switch (type) {
          case NUMBER:
            if (types.isString(value)) {
              value = parseInt(value, types.parseIntBase);
            }

            break;

          case STRING:
            if (types.isNumber(value)) {
              value += '';
            }

        }
      }

      if (Types['is' + Type](value)) {
        return value;
      }
    }; // the forctType method, returns the Type's literal or defaultValue if both value and replacement are not compatible


    return function (value, replacement) {
      var okValue, replacementType;

      if (value != null && void 0 !== (okValue = test(value))) {
        return okValue;
      }

      _logForce(1, Type, value);

      if (types.isDefined(replacement)) {
        replacementType = types["typeof"](replacement);

        if (replacement != null && void 0 !== (replacement = test(replacement))) {
          return replacement;
        } else {
          _logForce(2, Type, value);
        }
      }

      _logForce(3, Type, value);

      return LITERALS[type];
    };
  }; // test multiple values(arguments) for a given predicate. returns breakState if predicate is breakState for some value
  // when no break occured, ! breakState will be returned.


  testHasAndAll = function testHasAndAll(predicate, breakState) {
    var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var i, len, value;

    if (values.length < 1) {
      // testing 'has' or 'all' for 'undefined' should return true on calls without arguments
      return predicate === TYPES[UNDEFINED];
    }

    for (i = 0, len = values.length; i < len; i++) {
      value = values[i];

      if (predicate(value) === breakState) {
        return breakState;
      }
    }

    return !breakState;
  }; // generate all the is/not/has/all/force Types


  BREAK_IF_EQUAL = true;

  (function () {
    var predicate, results, type;
    results = [];

    for (type in TYPES) {
      predicate = TYPES[type];
      results.push(function (type, predicate) {
        var Type;

        Type = function () {
          switch (type) {
            case NAN:
              return 'NaN';

            case REGEXP:
              return 'RegExp';

            default:
              return upFirst(type);
          }
        }();

        Types['is' + Type] = predicate;

        Types['not' + Type] = function (value) {
          return !predicate(value);
        };

        Types['has' + Type] = function () {
          return testHasAndAll(predicate, BREAK_IF_EQUAL, arguments);
        };

        Types['all' + Type] = function () {
          return testHasAndAll(predicate, !BREAK_IF_EQUAL, arguments);
        }; // create only forceType of types found in LITERALS


        if (type in LITERALS) {
          Types['force' + Type] = createForce(type);
        }

        return Types['getFirst' + Type] = function () {
          var i, len, value;

          for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
            values[_key] = arguments[_key];
          }

          for (i = 0, len = values.length; i < len; i++) {
            value = values[i];

            if (Types['is' + Type](value)) {
              return value;
            }
          }
        };
      }(type, predicate));
    }

    return results;
  })();

  Types.intoArray = function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (args.length < 2) {
      if (types.isString(args[0])) {
        // to string, trim, limit to one consecutive space, back to array
        args = args.join('').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ').split(' ');
      } else if (types.isArray(args[0])) {
        args = args[0];
      }
    }

    return args;
  };

  Types.typeOf = Types["typeof"] = function (value) {
    var name, predicate;

    for (name in TYPES) {
      predicate = TYPES[name];

      if (predicate(value) === true) {
        return name;
      }
    }
  };

  Types["enum"] = Types.enumerate = function (items, offset) {
    var _enum, i, index, item, len;

    offset = types.forceNumber(offset, 0);
    _enum = createEnum();

    if (types.notArray(items)) {
      log("".concat(ENUM_ERR_PREFIX, " invalid or missing enumeration array"));
      return _enum;
    }

    for (index = i = 0, len = items.length; i < len; index = ++i) {
      item = items[index];

      if (types.isString(item)) {
        _enum[item] = index + offset;
      } else {
        log("".concat(ENUM_ERR_PREFIX, " ignored non-string item that was found in enumeration array"));
      }
    }

    types.forceFunction(Object.freeze)(_enum);
    return _enum;
  };

  if (typeof define !== "undefined" && define !== null && FUNCTION === (typeof define === "undefined" ? "undefined" : _typeof(define)) && define.amd) {
    define('types', [], function () {
      return Types;
    });
  }

  if ((typeof module === "undefined" ? "undefined" : _typeof(module)) !== UNDEFINED) {
    module.exports = Types;
  }

  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== UNDEFINED) {
    window.Types = Types;
  }
}).call(void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBeUJpRyxDQUFBLFlBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUEsS0FBQSxFQUFBLE9BQUEsRUFBQSxjQUFBLEVBQUEsSUFBQSxFQUFBLE9BQUEsRUFBQSxJQUFBLEVBQUEsZUFBQSxFQUFBLE9BQUEsRUFBQSxnQkFBQSxFQUFBLFFBQUEsRUFBQSxRQUFBLEVBQUEsZ0JBQUEsRUFBQSxlQUFBLEVBQUEsV0FBQSxFQUFBLEdBQUEsRUFBQSxJQUFBLEVBQUEsTUFBQSxFQUFBLE1BQUEsRUFBQSxNQUFBLEVBQUEsTUFBQSxFQUFBLE1BQUEsRUFBQSxLQUFBLEVBQUEsS0FBQSxFQUFBLFNBQUEsRUFBQSxVQUFBLEVBQUEsV0FBQSxFQUFBLFVBQUEsRUFBQSxHQUFBLEVBQUEsU0FBQSxFQUFBLGFBQUEsRUFBQSxNQUFBLEVBQUEsS0FBQSxFQUFBLE9BQUE7O0FBR2pHLEVBQUEsV0FBQSxHQUFpQixVQUFqQjtBQUNBLEVBQUEsT0FBQSxHQUFjLFFBQWQ7QUFDQSxFQUFBLGdCQUFBLGFBQW9CLFdBQXBCLGFBQUE7QUFDQSxFQUFBLGVBQUEsYUFBbUIsV0FBbkIsb0JBQUE7QUFDQSxFQUFBLGdCQUFBLGFBQW9CLFdBQXBCLG9DQUFBO0FBQ0EsRUFBQSxlQUFBLGFBQW1CLFdBQW5CLGtDQUFBO0FBRUEsRUFBQSxLQUFBLEdBQWEsT0FBYjtBQUNBLEVBQUEsT0FBQSxHQUFjLFNBQWQ7QUFDQSxFQUFBLElBQUEsR0FBWSxNQUFaO0FBQ0EsRUFBQSxPQUFBLEdBQWMsU0FBZDtBQUNBLEVBQUEsSUFBQSxHQUFZLE1BQVo7QUFDQSxFQUFBLFFBQUEsR0FBZSxVQUFmO0FBQ0EsRUFBQSxHQUFBLEdBQVcsS0FBWDtBQUNBLEVBQUEsSUFBQSxHQUFZLE1BQVo7QUFDQSxFQUFBLE1BQUEsR0FBYSxRQUFiO0FBQ0EsRUFBQSxNQUFBLEdBQWEsUUFBYjtBQUNBLEVBQUEsTUFBQSxHQUFhLFFBQWI7QUFDQSxFQUFBLE1BQUEsR0FBYSxRQUFiO0FBQ0EsRUFBQSxNQUFBLEdBQWEsUUFBYjtBQUNBLEVBQUEsU0FBQSxHQUFlLFdBQWY7QUFHQSxFQUFBLFFBQUEsK0NBQ0MsT0FERCxFQUNDLEtBREQsOEJBRUMsTUFGRCxFQUNDLEVBREQsOEJBR0MsTUFIRCxFQUNDLEVBREQsOEJBSUMsS0FKRCxFQUNDLEVBREQsOEJBS0MsUUFMRCxFQUtlLFlBQUEsQ0FKZCxDQURELDhCQU1DLE1BTkQsRUFNaUIsWUFBQTtBQUNqQixRQUFBLE1BQUE7QUFBRSxJQUFBLE1BQUEsR0FBUSxJQUFBLE1BQUEsRUFBUjtBQUNBLElBQUEsTUFBQSxRQUFBLEdBQWEsSUFBYjtBQUNBLFdBQU8sTUFBUDtBQVJELEdBS2dCLEVBTmpCLDhCQVVDLE1BVkQsRUFVYyxJQUFBLE1BQUEsRUFWZCxhQUFBOztBQWFBLEVBQUEsR0FBQSxHQUFTLGVBQUE7QUFBZSxRQUFHLEtBQUssQ0FBUixPQUFBLEVBQUE7QUFBQTs7YUFBc0IsWUFBQSxPQUFPLEVBQTdCLEdBQXNCLDJCOztBQUFyQyxHQUFUOztBQUNBLEVBQUEsU0FBQSxHQUFZLG9CQUFBLENBeENxRixDQXdDakcsQ0F4Q2lHLEM7OztBQTJDakcsRUFBQSxPQUFBLEdBQVcsaUJBQUEsR0FBQSxFQUFBO1dBQVcsR0FBQSxHQUFLLEdBQUcsQ0FBQSxDQUFBLENBQUgsQ0FBQSxXQUFBLEtBQXNCLEdBQUcsQ0FBQSxLQUFILENBQUcsQ0FBSCxDO0FBQXRDLEdBQVg7O0FBRUEsRUFBQSxVQUFBLEdBQWEsb0JBQUEsSUFBQSxFQUFBLEtBQUEsRUFBQTtXQUFtQixLQUFBLFlBQWlCLEk7QUE3Q2dELEdBNkNqRyxDQTdDaUcsQzs7O0FBZ0RqRyxFQUFBLE1BQUEsR0FBVSxnQkFBQSxLQUFBLEVBQUE7QUFBQSxRQUFTLElBQVQsdUVBQUEsTUFBQTtXQUEyQixRQUFBLEtBQUEsTUFBZ0IsSTtBQUEzQyxHQUFWOztBQUVBLEVBQUEsVUFBQSxHQUFZLHNCQUFBO0FBQ1osUUFBQSxLQUFBOztBQUFDLElBQUEsS0FBQSxHQUFPLEVBQVA7QUFDQSxJQUFBLE1BQU0sQ0FBTixjQUFBLENBQUEsS0FBQSxFQUFBLE9BQUEsRUFDQztBQUFBLE1BQUEsWUFBQSxFQUFBLEtBQUE7QUFDQSxNQUFBLFVBQUEsRUFEQSxLQUFBO0FBRUEsTUFBQSxLQUFBLEVBRkEsSUFBQTtBQUdBLE1BQUEsUUFBQSxFQUFhO0FBSGIsS0FERDtBQUtBLFdBQU8sS0FBUDtBQXpEZ0csR0FrRGpHLENBbERpRyxDOzs7QUE2RGpHLEVBQUEsS0FBQSx5Q0FDQyxTQURELEVBQ2dCLFVBQUEsS0FBQSxFQUFBO1dBQWEsS0FBQSxLQUFTLEtBQUEsQztBQUFyQyxHQURELDJCQUVDLElBRkQsRUFFWSxVQUFBLEtBQUEsRUFBQTtXQUFhLEtBQUEsS0FBUyxJO0FBRGpDLEdBREQsMkJBR0MsUUFIRCxFQUdlLFVBQUEsS0FBQSxFQUFBO1dBQWEsTUFBQSxDQUFBLEtBQUEsRUFBQSxRQUFBLEM7QUFGM0IsR0FERCwyQkFJQyxPQUpELEVBSWMsVUFBQSxLQUFBLEVBQUE7V0FBYSxNQUFBLENBQUEsS0FBQSxFQUFBLE9BQUEsQztBQUgxQixHQURELDJCQUtDLE1BTEQsRUFLYyxVQUFBLEtBQUEsRUFBQTtXQUFhLE1BQUEsQ0FBQSxLQUFBLEVBQUEsTUFBQSxDO0FBSjFCLEdBREQsMkJBTUMsS0FORCxFQU1hLFVBQUEsS0FBQSxFQUFBO1dBQWEsTUFBQSxDQUFBLEtBQUEsQ0FBQSxJQUFrQixVQUFBLENBQUEsS0FBQSxFQUFBLEtBQUEsQztBQUwzQyxHQURELDJCQU9DLE1BUEQsRUFPYyxVQUFBLEtBQUEsRUFBQTtXQUFhLE1BQUEsQ0FBQSxLQUFBLENBQUEsSUFBa0IsVUFBQSxDQUFBLE1BQUEsRUFBQSxLQUFBLEM7QUFONUMsR0FERCwyQkFRQyxJQVJELEVBUVksVUFBQSxLQUFBLEVBQUE7V0FBYSxNQUFBLENBQUEsS0FBQSxDQUFBLElBQWtCLFVBQUEsQ0FBQSxJQUFBLEVBQUEsS0FBQSxDO0FBUDFDLEdBREQsMkJBU0MsTUFURCxFQVNjLFVBQUEsS0FBQSxFQUFBO1dBQWEsTUFBQSxDQUFBLEtBQUEsRUFBQSxNQUFBLENBQUEsSUFBMkIsS0FBQSxLQUEzQixLQUFBLElBQWdELE1BQUEsQ0FBQSxLQUFBLENBQUEsSUFBa0IsVUFBQSxDQUFBLE1BQUEsRUFBcEIsS0FBb0IsQztBQVI1RixHQURELDJCQVVDLE1BVkQsRUFVYyxVQUFBLEtBQUEsRUFBQTtXQUFhLE1BQUEsQ0FBQSxLQUFBLENBQUEsSUFBbUIsS0FBQSxLQUFuQixJQUFBLElBQXdDLENBQUksVUFBQSxDQUFBLE9BQUEsRUFBNUMsS0FBNEMsQ0FBNUMsSUFBMkUsQ0FBSSxVQUFBLENBQUEsTUFBQSxFQUEvRSxLQUErRSxDQUEvRSxJQUE2RyxDQUFJLFVBQUEsQ0FBQSxLQUFBLEVBQWpILEtBQWlILENBQWpILElBQThJLENBQUksVUFBQSxDQUFBLE1BQUEsRUFBbEosS0FBa0osQ0FBbEosSUFBZ0wsQ0FBSSxVQUFBLENBQUEsSUFBQSxFQUFBLEtBQUEsQztBQVQ5TSxHQURELDJCQVdDLE1BWEQsRUFXYyxVQUFBLEtBQUEsRUFBQTtXQUFhLE1BQUEsQ0FBQSxLQUFBLEVBQUEsTUFBQSxDO0FBVjFCLEdBREQsMkJBWUMsR0FaRCxFQVlZLFVBQUEsS0FBQSxFQUFBO1dBQWEsTUFBQSxDQUFBLEtBQUEsRUFBQSxNQUFBLENBQUEsSUFBMkIsS0FBQSxLQUFELEs7QUFYbEQsR0FERCwyQkFhQyxJQWJELEVBYVksVUFBQSxLQUFBLEVBQUE7V0FBYSxLQUFLLENBQUwsV0FBQSxDQUFBLEtBQUEsRUFBQSxjQUFBLENBQUEsT0FBQSxDO0FBWnhCLEdBREQsMkJBY0MsT0FkRCxFQWNjLFVBQUEsS0FBQSxFQUFBO1dBQWEsS0FBQSxLQUFXLEtBQUEsQztBQUF4QixHQWRkLFVBQUE7O0FBZ0JBLEVBQUEsS0FBSyxDQUFMLGNBQUEsR0FBc0IsVUFBQSxLQUFBLEVBQUE7V0FBVyxLQUFLLENBQUwsTUFBSyxDQUFMLENBQUEsS0FBQSxLQUF3QixLQUFLLENBQUwsTUFBSyxDQUFMLENBQUEsS0FBQSxDO0FBN0V3QyxHQTZFakcsQ0E3RWlHLEM7OztBQWtGakcsRUFBQSxLQUFBLEdBQU8sS0FBQSxHQUdOOztBQUFBLElBQUEsWUFBQSxFQUFBLEVBQUE7QUFDQSxJQUFBLFdBQUEsRUFEQSxJQUFBO0FBRUEsSUFBQSxPQUFBLEVBRkEsSUFBQTtBQUlBLElBQUEsY0FBQSxFQUFpQiwwQkFBQTtBQUNoQixNQUFBLEtBQUssQ0FBTCxPQUFBLEdBQWUsS0FBZjthQUNBLE9BQU8sQ0FBUCxHQUFBLENBQUEsZ0JBQUEsQztBQU5ELEtBQUE7QUFRQSxJQUFBLGFBQUEsRUFBZ0IseUJBQUE7QUFDZixNQUFBLEtBQUssQ0FBTCxPQUFBLEdBQWUsSUFBZjthQUNBLE9BQU8sQ0FBUCxHQUFBLENBQUEsZUFBQSxDO0FBVkQsS0FBQTtBQVlBLElBQUEsUUFBQSxFQUFhLGtCQUFBLFdBQUEsRUFBQTthQUNaLFNBQUEsR0FBVSxtQkFBQSxRQUFBLEVBQUEsWUFBQSxFQUFBLGVBQUEsRUFBQTtBQUNaLFlBQUEsR0FBQTs7QUFBRyxZQUFJLEtBQUssQ0FBTCxVQUFBLENBQUosV0FBSSxDQUFKLEVBQUE7aUJBQXVDLFdBQUEsQ0FBQSxRQUFBLEVBQUEsWUFBQSxFQUF2QyxlQUF1QyxDO0FBQXZDLFNBQUEsTUFBQTtBQUVDLFVBQUEsR0FBQSxHQUFLLFlBQUw7O0FBQ0Esa0JBQUEsUUFBQTtBQUFBLGlCQUFBLENBQUE7QUFDYSxjQUFBLEdBQUEsSUFBTSxvQ0FBbUMsWUFBekM7QUFBUDs7QUFETixpQkFBQSxDQUFBO0FBRWEsY0FBQSxHQUFBLElBQU0scUNBQW9DLFlBQTFDO0FBQVA7O0FBRk4saUJBQUEsQ0FBQTtBQUdhLGNBQUEsR0FBQSxJQUFNLDZDQUFBLFlBQUEsR0FBMEQsVUFBaEU7QUFIYjs7aUJBSUEsR0FBQSxDQUFJLGdCQUFBLEdBUEwsR0FPQyxDOztBQVJRLE87QUFERTtBQVpiLEdBSEQsQ0FsRmlHLEM7O0FBZ0hqRyxFQUFBLFdBQUEsR0FBYSxxQkFBQSxJQUFBLEVBQUE7QUFFYixRQUFBLElBQUEsRUFBQSxJQUFBO0FBQUMsSUFBQSxJQUFBLEdBQU0sT0FBQSxDQUFQLElBQU8sQ0FBTixDQUZZLEM7O0FBS1osSUFBQSxJQUFBLEdBQU0sY0FBQSxLQUFBLEVBQUE7QUFDTCxVQUFHLEtBQUssQ0FBUixXQUFBLEVBQUE7QUFBMEIsZ0JBQUEsSUFBQTtBQUFBLGVBQUEsTUFBQTtBQUNSLGdCQUFHLEtBQUssQ0FBTCxRQUFBLENBQUgsS0FBRyxDQUFILEVBQUE7QUFDaEIsY0FBQSxLQUFBLEdBQU8sUUFBQSxDQUFBLEtBQUEsRUFBZ0IsS0FBSyxDQURaLFlBQ1QsQ0FBUDs7O0FBREk7O0FBRG9CLGVBQUEsTUFBQTtBQUdSLGdCQUFHLEtBQUssQ0FBTCxRQUFBLENBQUgsS0FBRyxDQUFILEVBQUE7QUFDaEIsY0FBQSxLQUFBLElBRGdCLEVBQ2hCOzs7QUFKd0I7OztBQUsxQixVQUFnQixLQUFLLENBQUMsT0FBTixJQUFLLENBQUwsQ0FBaEIsS0FBZ0IsQ0FBaEIsRUFBQTtBQUFBLGVBQUEsS0FBQTs7QUFURixLQUdDLENBTFksQzs7O0FBY1osV0FBTyxVQUFBLEtBQUEsRUFBQSxXQUFBLEVBQUE7QUFFUixVQUFBLE9BQUEsRUFBQSxlQUFBOztBQUFFLFVBQWtCLEtBQUEsSUFBQSxJQUFBLElBQVksS0FBQSxDQUFBLE1BQWUsT0FBQSxHQUFTLElBQUEsQ0FBdEQsS0FBc0QsQ0FBeEIsQ0FBOUIsRUFBQTtBQUFBLGVBQUEsT0FBQTs7O0FBRUEsTUFBQSxTQUFBLENBQUEsQ0FBQSxFQUFBLElBQUEsRUFBQSxLQUFBLENBQUE7O0FBRUEsVUFBRyxLQUFLLENBQUwsU0FBQSxDQUFILFdBQUcsQ0FBSCxFQUFBO0FBQ0MsUUFBQSxlQUFBLEdBQWlCLEtBQUEsVUFBQSxDQUFBLFdBQUEsQ0FBakI7O0FBQ0EsWUFBRyxXQUFBLElBQUEsSUFBQSxJQUFrQixLQUFBLENBQUEsTUFBZSxXQUFBLEdBQWEsSUFBQSxDQUFqRCxXQUFpRCxDQUE1QixDQUFyQixFQUFBO0FBQ0MsaUJBREQsV0FDQztBQURELFNBQUEsTUFBQTtBQUVLLFVBQUEsU0FBQSxDQUFBLENBQUEsRUFBQSxJQUFBLEVBRkwsS0FFSyxDQUFBO0FBSk47OztBQU1BLE1BQUEsU0FBQSxDQUFBLENBQUEsRUFBQSxJQUFBLEVBQUEsS0FBQSxDQUFBOztBQUVBLGFBQU8sUUFBUSxDQUFBLElBQUEsQ0FBZjtBQWRNLEtBQVA7QUE5SGdHLEdBZ0hqRyxDQWhIaUcsQzs7OztBQW1KakcsRUFBQSxhQUFBLEdBQWUsdUJBQUEsU0FBQSxFQUFBLFVBQUEsRUFBQTtBQUFBLFFBQXlCLE1BQXpCLHVFQUFBLEVBQUE7QUFDZixRQUFBLENBQUEsRUFBQSxHQUFBLEVBQUEsS0FBQTs7QUFDQyxRQUE0QyxNQUFNLENBQU4sTUFBQSxHQUE1QyxDQUFBLEVBQUE7O0FBQUEsYUFBUyxTQUFBLEtBQWEsS0FBSyxDQUEzQixTQUEyQixDQUEzQjs7O0FBRUEsU0FBQSxDQUFBLEdBQUEsQ0FBQSxFQUFBLEdBQUEsR0FBQSxNQUFBLENBQUEsTUFBQSxFQUFBLENBQUEsR0FBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBLEVBQUE7OztBQUNDLFVBQXFCLFNBQUEsQ0FBQSxLQUFBLENBQUEsS0FBckIsVUFBQSxFQUFBO0FBQUEsZUFBQSxVQUFBOztBQUREOztBQUdBLFdBQU8sQ0FBSSxVQUFYO0FBMUpnRyxHQW1KakcsQ0FuSmlHLEM7OztBQStKakcsRUFBQSxjQUFBLEdBQWdCLElBQWhCOztBQUNHLEdBQUEsWUFBQTtBQUFFLFFBQUEsU0FBQSxFQUFBLE9BQUEsRUFBQSxJQUFBO0FBQUMsSUFBQSxPQUFBLEdBQUEsRUFBQTs7QUFBQSxTQUFBLElBQUEsSUFBQSxLQUFBLEVBQUE7O21CQUFxQyxVQUFBLElBQUEsRUFBQSxTQUFBLEVBQUE7QUFFM0MsWUFBQSxJQUFBOztBQUFDLFFBQUEsSUFBQSxHQUFBLFlBQUE7QUFBTSxrQkFBQSxJQUFBO0FBQUEsaUJBQUEsR0FBQTtxQkFDUyxLOztBQURULGlCQUFBLE1BQUE7cUJBRVksUTs7QUFGWjtxQkFHQSxPQUFBLENBQUEsSUFBQSxDO0FBSEE7U0FBTixFQUFBOztBQUtBLFFBQUEsS0FBSyxDQUFFLE9BQVAsSUFBSyxDQUFMLEdBQXNCLFNBQXRCOztBQUNBLFFBQUEsS0FBSyxDQUFFLFFBQVAsSUFBSyxDQUFMLEdBQXVCLFVBQUEsS0FBQSxFQUFBO2lCQUFhLENBQUksU0FBQSxDQUFBLEtBQUEsQztBQUFqQixTQUF2Qjs7QUFDQSxRQUFBLEtBQUssQ0FBRSxRQUFQLElBQUssQ0FBTCxHQUF1QixZQUFBO2lCQUFHLGFBQUEsQ0FBQSxTQUFBLEVBQUEsY0FBQSxFQUFBLFNBQUEsQztBQUFILFNBQXZCOztBQUNBLFFBQUEsS0FBSyxDQUFFLFFBQVAsSUFBSyxDQUFMLEdBQXVCLFlBQUE7aUJBQUcsYUFBQSxDQUFBLFNBQUEsRUFBeUIsQ0FBekIsY0FBQSxFQUFBLFNBQUEsQztBQVIzQixTQVFDLENBVjBDLEM7OztBQWExQyxZQUFHLElBQUEsSUFBSCxRQUFBLEVBQUE7QUFBeUIsVUFBQSxLQUFLLENBQUUsVUFBUCxJQUFLLENBQUwsR0FBd0IsV0FBQSxDQUFqRCxJQUFpRCxDQUF4Qjs7O2VBRXpCLEtBQUssQ0FBRSxhQUFQLElBQUssQ0FBTCxHQUEyQixZQUFBO0FBQzVCLGNBQUEsQ0FBQSxFQUFBLEdBQUEsRUFBQSxLQUFBOztBQUQ0Qiw0Q0FBQSxNQUFBO0FBQUEsWUFBQSxNQUFBO0FBQUE7O0FBQzFCLGVBQUEsQ0FBQSxHQUFBLENBQUEsRUFBQSxHQUFBLEdBQUEsTUFBQSxDQUFBLE1BQUEsRUFBQSxDQUFBLEdBQUEsR0FBQSxFQUFBLENBQUEsRUFBQSxFQUFBOzs7QUFBeUIsZ0JBQWdCLEtBQUssQ0FBRSxPQUFQLElBQUssQ0FBTCxDQUFoQixLQUFnQixDQUFoQixFQUFBO0FBQUEscUJBQUEsS0FBQTs7QUFBekI7QUFEMEIsUztBQWZlLE9BQUEsQ0FBRSxJQUFGLEVBQVEsU0FBUixDO0FBQXJDOzs7QUFBSCxHQUFBOztBQXFCSCxFQUFBLEtBQUssQ0FBTCxTQUFBLEdBQWlCLFlBQUE7QUFBQSx1Q0FBQSxJQUFBO0FBQUEsTUFBQSxJQUFBO0FBQUE7O0FBQ2hCLFFBQUcsSUFBSSxDQUFKLE1BQUEsR0FBSCxDQUFBLEVBQUE7QUFDQyxVQUFHLEtBQUssQ0FBTCxRQUFBLENBQWUsSUFBSSxDQUF0QixDQUFzQixDQUFuQixDQUFILEVBQUE7O0FBRUMsUUFBQSxJQUFBLEdBQU0sSUFBSSxDQUFKLElBQUEsQ0FBQSxFQUFBLEVBQUEsT0FBQSxDQUFBLFlBQUEsRUFBQSxFQUFBLEVBQUEsT0FBQSxDQUFBLE1BQUEsRUFBQSxHQUFBLEVBQUEsS0FBQSxDQUZQLEdBRU8sQ0FBTjtBQUZELE9BQUEsTUFHSyxJQUFHLEtBQUssQ0FBTCxPQUFBLENBQWMsSUFBSSxDQUFyQixDQUFxQixDQUFsQixDQUFILEVBQUE7QUFDSixRQUFBLElBQUEsR0FBTSxJQUFJLENBRE4sQ0FDTSxDQUFWO0FBTEY7OztBQU1BLFdBQU8sSUFBUDtBQVBnQixHQUFqQjs7QUFZQSxFQUFBLEtBQUssQ0FBTCxNQUFBLEdBQWMsS0FBQSxVQUFBLEdBQWMsVUFBQSxLQUFBLEVBQUE7QUFDNUIsUUFBQSxJQUFBLEVBQUEsU0FBQTs7QUFBQyxTQUFBLElBQUEsSUFBQSxLQUFBLEVBQUE7OztBQUNDLFVBQWUsU0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFmLElBQUEsRUFBQTtBQUFBLGVBQUEsSUFBQTs7QUFERDtBQUQyQixHQUE1Qjs7QUFPQSxFQUFBLEtBQUEsUUFBQSxHQUFZLEtBQUssQ0FBTCxTQUFBLEdBQWlCLFVBQUEsS0FBQSxFQUFBLE1BQUEsRUFBQTtBQUM3QixRQUFBLEtBQUEsRUFBQSxDQUFBLEVBQUEsS0FBQSxFQUFBLElBQUEsRUFBQSxHQUFBOztBQUFDLElBQUEsTUFBQSxHQUFTLEtBQUssQ0FBTCxXQUFBLENBQUEsTUFBQSxFQUFBLENBQUEsQ0FBVDtBQUNBLElBQUEsS0FBQSxHQUFTLFVBQUEsRUFBVDs7QUFFQSxRQUFHLEtBQUssQ0FBTCxRQUFBLENBQUgsS0FBRyxDQUFILEVBQUE7QUFDQyxNQUFBLEdBQUEsV0FBQSxlQUFBLDJDQUFBO0FBQ0EsYUFGRCxLQUVDOzs7QUFFRCxTQUFBLEtBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxFQUFBLEdBQUEsR0FBQSxLQUFBLENBQUEsTUFBQSxFQUFBLENBQUEsR0FBQSxHQUFBLEVBQUEsS0FBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBOzs7QUFDQyxVQUFHLEtBQUssQ0FBTCxRQUFBLENBQUgsSUFBRyxDQUFILEVBQUE7QUFBNEIsUUFBQSxLQUFLLENBQUwsSUFBSyxDQUFMLEdBQWdCLEtBQUEsR0FBNUMsTUFBNEI7QUFBNUIsT0FBQSxNQUFBO0FBQ0ssUUFBQSxHQUFBLFdBREwsZUFDSyxrRUFBQTs7QUFGTjs7QUFJQSxJQUFBLEtBQUssQ0FBTCxhQUFBLENBQXFCLE1BQU0sQ0FBM0IsTUFBQSxFQUFBLEtBQUE7QUFDQSxXQUFPLEtBQVA7QUFiNEIsR0FBN0I7O0FBa0JBLE1BQUcsT0FBQSxNQUFBLEtBQUEsV0FBQSxJQUFBLE1BQUEsS0FBQSxJQUFBLElBQWMsUUFBQSxhQUFkLE1BQWMseUNBQWQsTUFBYyxFQUFkLElBQThDLE1BQU0sQ0FBdkQsR0FBQSxFQUFBO0FBQ0MsSUFBQSxNQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsRUFBb0IsWUFBQTthQUFHLEs7QUFEeEIsS0FDQyxDQUFBOzs7QUFFRCxNQUFHLFFBQUEsTUFBQSx5Q0FBQSxNQUFBLE9BQUgsU0FBQSxFQUFBO0FBQ0MsSUFBQSxNQUFNLENBQU4sT0FBQSxHQURELEtBQ0M7OztBQUVELE1BQUcsUUFBQSxNQUFBLHlDQUFBLE1BQUEsT0FBSCxTQUFBLEVBQUE7QUFDQyxJQUFBLE1BQU0sQ0FBTixLQUFBLEdBREQsS0FDQzs7Q0FqT2dHLEUsSUFBQSIsInNvdXJjZXNDb250ZW50IjpbIiNcdHR5cGVzLmpzIC0gQSB0aW55IGFuZCBmYXN0IGR5bmFtaWMgdHlwZSBjaGVja2VyL2VuZm9yY2VyIGxpYnJhcnlcbiNcbiMgTUlUIExpY2Vuc2VcbiNcbiMgQ29weXJpZ2h0IChjKSAyMDE0IERlbm5pcyBSYXltb25kbyB2YW4gZGVyIFNsdWlzXG4jXG4jIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiMgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuIyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4jIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiMgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4jIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4jXG4jIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuIyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4jIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiMgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuIyBTT0ZUV0FSRS5cbiNcblxuIyBoZWF2aWx5IHJlZmFjdG9yZWQgdG8gcmVkdWNlIHNpemUgd2hpbGUgb3B0aW1pemluZyBmb3Igc3BlZWQsIGF0IHRoZSBjb3N0IG9mIHNvbWUgcmVhZGFiaWxpdHkuLlxuXG5cbk1PRFVMRV9OQU1FXHRcdFx0XHQ9ICd0eXBlcy5qcydcbkVOVU1fSURcdFx0XHRcdFx0PSAnX0VOVU1fJ1xuRk9SQ0VfTVNHX1BSRUZJWFx0XHQ9IFwiI3tNT0RVTEVfTkFNRX0gLSBmb3JjZVwiXG5FTlVNX0VSUl9QUkVGSVhcdFx0PSBcIiN7TU9EVUxFX05BTUV9IC0gZW51bTogRVJST1IsXCJcbkxPR0dJTkdfRElTQUJMRURcdFx0PSBcIiN7TU9EVUxFX05BTUV9IC0gYWxsIGxvZ2dpbmcgZGlzYWJsZWQgYnkgdXNlclwiXG5MT0dHSU5HX0VOQUJMRURcdFx0PSBcIiN7TU9EVUxFX05BTUV9IC0gbG9nZ2luZyByZS1lbmFibGVkIGJ5IHVzZXJcIlxuXG5BUlJBWVx0XHRcdFx0XHRcdD0gJ2FycmF5J1xuQk9PTEVBTlx0XHRcdFx0XHQ9ICdib29sZWFuJ1xuREFURVx0XHRcdFx0XHRcdD0gJ2RhdGUnXG5ERUZJTkVEXHRcdFx0XHRcdD0gJ2RlZmluZWQnXG5FTlVNXHRcdFx0XHRcdFx0PSAnZW51bSdcbkZVTkNUSU9OXHRcdFx0XHRcdD0gJ2Z1bmN0aW9uJ1xuTkFOXHRcdFx0XHRcdFx0PSAnbmFuJ1xuTlVMTFx0XHRcdFx0XHRcdD0gJ251bGwnXG5OVU1CRVJcdFx0XHRcdFx0PSAnbnVtYmVyJ1xuT0JKRUNUXHRcdFx0XHRcdD0gJ29iamVjdCdcblJFR0VYUFx0XHRcdFx0XHQ9ICdyZWdleHAnXG5TVFJJTkdcdFx0XHRcdFx0PSAnc3RyaW5nJ1xuU1lNQk9MXHRcdFx0XHRcdD0gJ3N5bWJvbCdcblVOREVGSU5FRFx0XHRcdFx0PSAndW5kZWZpbmVkJ1xuXG5cbkxJVEVSQUxTPVxuXHRbQk9PTEVBTl1cdFx0OiBmYWxzZVxuXHRbU1RSSU5HXVx0XHRcdDogJydcblx0W09CSkVDVF1cdFx0XHQ6IHt9XG5cdFtBUlJBWV1cdFx0XHQ6IFtdXG5cdFtGVU5DVElPTl1cdFx0OiAtPlxuXHRbTlVNQkVSXVx0XHRcdDogZG8gLT5cblx0XHRudW1iZXI9IG5ldyBOdW1iZXJcblx0XHRudW1iZXIudm9pZD0gdHJ1ZVxuXHRcdHJldHVybiBudW1iZXJcblx0W1JFR0VYUF1cdFx0XHQ6IG5ldyBSZWdFeHBcblxuXG5sb2cgXHRcdFx0PSAoIGFyZ3MuLi4gKSAtPiBpZiBUeXBlcy5sb2dnaW5nIHRoZW4gY29uc29sZS5sb2cgYXJncy4uLlxubG9nRm9yY2VcdFx0PSAtPlxuXG4jIGFuIHVuc2FmZSBpbnRlcm5hbCBmb3IgbWFraW5nIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSB0eXBlIGlkIHVwcGVyY2FzZVxudXBGaXJzdFx0XHQ9ICggc3RyICkgLT4gc3RyPSBzdHJbMF0udG9VcHBlckNhc2UoKSsgc3RyWzEuLl1cblxuaW5zdGFuY2VPZlx0PSAoIHR5cGUsIHZhbHVlICkgLT4gdmFsdWUgaW5zdGFuY2VvZiB0eXBlXG5cbiMgdHlwZSBkZWZhdWx0cyB0byBvYmplY3QsIGZvciBpbnRlcm5hbCBjYW4gZG8sIHNhdmVzIGZvciBhIGZldyBieXRlcy4uXG50eXBlT2ZcdFx0PSAoIHZhbHVlLCB0eXBlPSBPQkpFQ1QgKSAtPiB0eXBlb2YgdmFsdWUgaXMgdHlwZVxuXG5jcmVhdGVFbnVtPSAtPlxuXHRfZW51bT0ge31cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5IF9lbnVtLCBFTlVNX0lELFxuXHRcdGNvbmZpZ3VyYWJsZVx0OiBmYWxzZVxuXHRcdGVudW1lcmFibGVcdFx0OiBmYWxzZVxuXHRcdHZhbHVlXHRcdFx0XHQ6IHRydWVcblx0XHR3cml0YWJsZVx0XHRcdDogZmFsc2Vcblx0cmV0dXJuIF9lbnVtXG5cblxuIyBhbGwgZGVmaW5pdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBpc1t0eXBlXSwgbm90W3R5cGVdLCBldGMuLiB0ZXN0c1xuVFlQRVM9XG5cdFtVTkRFRklORURdXHRcdDogKCB2YWx1ZSApIC0+IHZhbHVlIGlzIHVuZGVmaW5lZFxuXHRbTlVMTF1cdFx0XHQ6ICggdmFsdWUgKSAtPiB2YWx1ZSBpcyBudWxsXG5cdFtGVU5DVElPTl1cdFx0OiAoIHZhbHVlICkgLT4gdHlwZU9mIHZhbHVlLCBGVU5DVElPTlxuXHRbQk9PTEVBTl1cdFx0OiAoIHZhbHVlICkgLT4gdHlwZU9mIHZhbHVlLCBCT09MRUFOXG5cdFtTVFJJTkddXHRcdFx0OiAoIHZhbHVlICkgLT4gdHlwZU9mIHZhbHVlLCBTVFJJTkdcblx0W0FSUkFZXVx0XHRcdDogKCB2YWx1ZSApIC0+IHR5cGVPZih2YWx1ZSkgYW5kIGluc3RhbmNlT2YgQXJyYXksIHZhbHVlXG5cdFtSRUdFWFBdXHRcdFx0OiAoIHZhbHVlICkgLT4gdHlwZU9mKHZhbHVlKSBhbmQgaW5zdGFuY2VPZiBSZWdFeHAsIHZhbHVlXG5cdFtEQVRFXVx0XHRcdDogKCB2YWx1ZSApIC0+IHR5cGVPZih2YWx1ZSkgYW5kIGluc3RhbmNlT2YgRGF0ZSwgdmFsdWVcblx0W05VTUJFUl1cdFx0XHQ6ICggdmFsdWUgKSAtPiB0eXBlT2YodmFsdWUsIE5VTUJFUikgYW5kICh2YWx1ZSBpcyB2YWx1ZSkgb3IgKCB0eXBlT2YodmFsdWUpIGFuZCBpbnN0YW5jZU9mKE51bWJlciwgdmFsdWUpIClcblx0W09CSkVDVF1cdFx0XHQ6ICggdmFsdWUgKSAtPiB0eXBlT2YodmFsdWUpIGFuZCAodmFsdWUgaXNudCBudWxsKSBhbmQgbm90IGluc3RhbmNlT2YoQm9vbGVhbiwgdmFsdWUpIGFuZCBub3QgaW5zdGFuY2VPZihOdW1iZXIsIHZhbHVlKSBhbmQgbm90IGluc3RhbmNlT2YoQXJyYXksIHZhbHVlKSBhbmQgbm90IGluc3RhbmNlT2YoUmVnRXhwLCB2YWx1ZSkgYW5kIG5vdCBpbnN0YW5jZU9mKERhdGUsIHZhbHVlKVxuXHRbU1lNQk9MXVx0XHRcdDogKCB2YWx1ZSApIC0+IHR5cGVPZiB2YWx1ZSwgU1lNQk9MXG5cdFtOQU5dXHRcdFx0XHQ6ICggdmFsdWUgKSAtPiB0eXBlT2YodmFsdWUsIE5VTUJFUikgYW5kICh2YWx1ZSBpc250IHZhbHVlKVxuXHRbRU5VTV1cdFx0XHQ6ICggdmFsdWUgKSAtPiBUeXBlcy5mb3JjZU9iamVjdCh2YWx1ZSkuaGFzT3duUHJvcGVydHkgRU5VTV9JRFxuXHRbREVGSU5FRF1cdFx0OiAoIHZhbHVlICkgLT4gdmFsdWUgaXNudCB1bmRlZmluZWRcblxuVFlQRVMuU3RyaW5nT3JOdW1iZXI9ICh2YWx1ZSkgLT4gVFlQRVNbU1RSSU5HXSh2YWx1ZSkgb3IgVFlQRVNbTlVNQkVSXSh2YWx1ZSlcblxuXG5cbiMgZGVmaW5lIHRoZSBtYWluIG9iamVjdCB0aGF0IHRoaXMgbW9kdWxlIHJldHVybnNcblR5cGVzPSB0eXBlcz1cblxuXHQjIHVzZWQgYnkgZm9yY2VOdW1iZXIgdG8gc2V0IHRoZSBSYWRpeCwgZGVmYXVsdHMgdG8gZGVjaW1hbHNcblx0cGFyc2VJbnRCYXNlXHQ6IDEwXG5cdGF1dG9Db252ZXJ0XHRcdDogdHJ1ZVxuXHRsb2dnaW5nXHRcdFx0OiB0cnVlXG5cblx0ZGlzYWJsZUxvZ2dpbmdcdDogLT5cblx0XHRUeXBlcy5sb2dnaW5nPSBmYWxzZVxuXHRcdGNvbnNvbGUubG9nIExPR0dJTkdfRElTQUJMRURcblxuXHRlbmFibGVMb2dnaW5nXHQ6IC0+XG5cdFx0VHlwZXMubG9nZ2luZz0gdHJ1ZVxuXHRcdGNvbnNvbGUubG9nIExPR0dJTkdfRU5BQkxFRFxuXG5cdGxvZ0ZvcmNlXHRcdFx0OiAoIGV4dGVybmFsTG9nICkgLT5cblx0XHRsb2dGb3JjZT0gKCBlcnJMZXZlbCwgZXhwZWN0ZWRUeXBlLCBlbmNvdW50ZXJlZFR5cGUgKSAtPlxuXHRcdFx0aWYgKFR5cGVzLmlzRnVuY3Rpb24gZXh0ZXJuYWxMb2cpIHRoZW4gZXh0ZXJuYWxMb2cgZXJyTGV2ZWwsIGV4cGVjdGVkVHlwZSwgZW5jb3VudGVyZWRUeXBlXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG1zZz0gZXhwZWN0ZWRUeXBlXG5cdFx0XHRcdHN3aXRjaCBlcnJMZXZlbFxuXHRcdFx0XHRcdHdoZW4gMSB0aGVuIG1zZys9IFwiOiBpbml0aWFsIHZhbHVlIGlzIG5vdCBvZiB0eXBlIFwiKyBleHBlY3RlZFR5cGVcblx0XHRcdFx0XHR3aGVuIDIgdGhlbiBtc2crPSBcIjogb3B0aW9uYWwgdmFsdWUgaXMgbm90IG9mIHR5cGUgXCIrIGV4cGVjdGVkVHlwZVxuXHRcdFx0XHRcdHdoZW4gMyB0aGVuIG1zZys9IFwiOiBubyB2YWxpZCB0eXBlIGZvdW5kLCByZXR1cm5pbmcgYSB0eXBlIFwiKyBleHBlY3RlZFR5cGUrIFwiIGxpdGVyYWxcIlxuXHRcdFx0XHRsb2cgRk9SQ0VfTVNHX1BSRUZJWCsgbXNnXG5cblxuXG5cbiMgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYWxsIFR5cGVzLmZvcmNlW3R5cGVdIHZhcmlhdGlvbnNcbmNyZWF0ZUZvcmNlPSAoIHR5cGUgKSAtPlxuXG5cdFR5cGU9IHVwRmlyc3QgdHlwZVxuXG5cdCMgY29udmVydCB2YWx1ZSBpbiBjYXNlIGluaXRpYWwgVHlwZSB0ZXN0IGZhaWxlZC4gZmFpbGVkIGNvbnZlcnNpb24gcmV0dXJucyB1bmRlZmluZWRcblx0dGVzdD0gKCB2YWx1ZSApIC0+XG5cdFx0aWYgdHlwZXMuYXV0b0NvbnZlcnQgdGhlbiBzd2l0Y2ggdHlwZVxuXHRcdFx0d2hlbiBOVU1CRVIgdGhlbiBpZiB0eXBlcy5pc1N0cmluZyB2YWx1ZVxuXHRcdFx0XHR2YWx1ZT0gcGFyc2VJbnQgdmFsdWUsIHR5cGVzLnBhcnNlSW50QmFzZVxuXHRcdFx0d2hlbiBTVFJJTkcgdGhlbiBpZiB0eXBlcy5pc051bWJlciB2YWx1ZVxuXHRcdFx0XHR2YWx1ZSs9ICcnXG5cdFx0cmV0dXJuIHZhbHVlIGlmIFR5cGVzWydpcycrIFR5cGVdIHZhbHVlXG5cblx0IyB0aGUgZm9yY3RUeXBlIG1ldGhvZCwgcmV0dXJucyB0aGUgVHlwZSdzIGxpdGVyYWwgb3IgZGVmYXVsdFZhbHVlIGlmIGJvdGggdmFsdWUgYW5kIHJlcGxhY2VtZW50IGFyZSBub3QgY29tcGF0aWJsZVxuXHRyZXR1cm4gKCB2YWx1ZSwgcmVwbGFjZW1lbnQgKSAtPlxuXG5cdFx0cmV0dXJuIG9rVmFsdWUgaWYgdmFsdWU/IGFuZCAodW5kZWZpbmVkIGlzbnQgb2tWYWx1ZT0gdGVzdCB2YWx1ZSlcblxuXHRcdGxvZ0ZvcmNlIDEsIFR5cGUsIHZhbHVlXG5cblx0XHRpZiB0eXBlcy5pc0RlZmluZWQgcmVwbGFjZW1lbnRcblx0XHRcdHJlcGxhY2VtZW50VHlwZT0gdHlwZXMudHlwZW9mIHJlcGxhY2VtZW50XG5cdFx0XHRpZiByZXBsYWNlbWVudD8gYW5kICh1bmRlZmluZWQgaXNudCByZXBsYWNlbWVudD0gdGVzdCByZXBsYWNlbWVudClcblx0XHRcdFx0cmV0dXJuIHJlcGxhY2VtZW50XG5cdFx0XHRlbHNlIGxvZ0ZvcmNlIDIsIFR5cGUsIHZhbHVlXG5cblx0XHRsb2dGb3JjZSAzLCBUeXBlLCB2YWx1ZVxuXG5cdFx0cmV0dXJuIExJVEVSQUxTWyB0eXBlIF1cblxuXG5cblxuIyB0ZXN0IG11bHRpcGxlIHZhbHVlcyhhcmd1bWVudHMpIGZvciBhIGdpdmVuIHByZWRpY2F0ZS4gcmV0dXJucyBicmVha1N0YXRlIGlmIHByZWRpY2F0ZSBpcyBicmVha1N0YXRlIGZvciBzb21lIHZhbHVlXG4jIHdoZW4gbm8gYnJlYWsgb2NjdXJlZCwgISBicmVha1N0YXRlIHdpbGwgYmUgcmV0dXJuZWQuXG50ZXN0SGFzQW5kQWxsPSAoIHByZWRpY2F0ZSwgYnJlYWtTdGF0ZSwgdmFsdWVzPSBbXSApIC0+XG5cdCMgdGVzdGluZyAnaGFzJyBvciAnYWxsJyBmb3IgJ3VuZGVmaW5lZCcgc2hvdWxkIHJldHVybiB0cnVlIG9uIGNhbGxzIHdpdGhvdXQgYXJndW1lbnRzXG5cdHJldHVybiAoIHByZWRpY2F0ZSBpcyBUWVBFU1tVTkRFRklORURdICkgaWYgdmFsdWVzLmxlbmd0aCA8IDFcblxuXHRmb3IgdmFsdWUgaW4gdmFsdWVzXG5cdFx0cmV0dXJuIGJyZWFrU3RhdGUgaWYgcHJlZGljYXRlKHZhbHVlKSBpcyBicmVha1N0YXRlXG5cblx0cmV0dXJuIG5vdCBicmVha1N0YXRlXG5cblxuXG4jIGdlbmVyYXRlIGFsbCB0aGUgaXMvbm90L2hhcy9hbGwvZm9yY2UgVHlwZXNcbkJSRUFLX0lGX0VRVUFMPSB0cnVlXG5kbyAtPiBmb3IgdHlwZSwgcHJlZGljYXRlIG9mIFRZUEVTIHRoZW4gZG8gKCB0eXBlLCBwcmVkaWNhdGUgKSAtPlxuXG5cdFR5cGU9IHN3aXRjaCB0eXBlXG5cdFx0d2hlbiBOQU4gdGhlbiAnTmFOJ1xuXHRcdHdoZW4gUkVHRVhQIHRoZW4gJ1JlZ0V4cCdcblx0XHRlbHNlIHVwRmlyc3QgdHlwZVxuXG5cdFR5cGVzWyAnaXMnKyBUeXBlIF1cdD0gcHJlZGljYXRlXG5cdFR5cGVzWyAnbm90JysgVHlwZSBdXHQ9ICggdmFsdWUgKSAtPiBub3QgcHJlZGljYXRlIHZhbHVlXG5cdFR5cGVzWyAnaGFzJysgVHlwZSBdXHQ9IC0+IHRlc3RIYXNBbmRBbGwgcHJlZGljYXRlLCBCUkVBS19JRl9FUVVBTCwgYXJndW1lbnRzXG5cdFR5cGVzWyAnYWxsJysgVHlwZSBdXHQ9IC0+IHRlc3RIYXNBbmRBbGwgcHJlZGljYXRlLCBub3QgQlJFQUtfSUZfRVFVQUwsIGFyZ3VtZW50c1xuXG5cdCMgY3JlYXRlIG9ubHkgZm9yY2VUeXBlIG9mIHR5cGVzIGZvdW5kIGluIExJVEVSQUxTXG5cdGlmIHR5cGUgb2YgTElURVJBTFMgdGhlbiBUeXBlc1sgJ2ZvcmNlJysgVHlwZSBdPSBjcmVhdGVGb3JjZSB0eXBlXG5cblx0VHlwZXNbICdnZXRGaXJzdCcrIFR5cGUgXT0gKCB2YWx1ZXMuLi4gKSAtPlxuXHRcdGZvciB2YWx1ZSBpbiB2YWx1ZXMgdGhlbiByZXR1cm4gdmFsdWUgaWYgVHlwZXNbICdpcycrIFR5cGUgXSB2YWx1ZVxuXG5cblxuXG5UeXBlcy5pbnRvQXJyYXk9ICggYXJncy4uLiApIC0+XG5cdGlmIGFyZ3MubGVuZ3RoIDwgMlxuXHRcdGlmIHR5cGVzLmlzU3RyaW5nIGFyZ3NbIDAgXVxuXHRcdFx0IyB0byBzdHJpbmcsIHRyaW0sIGxpbWl0IHRvIG9uZSBjb25zZWN1dGl2ZSBzcGFjZSwgYmFjayB0byBhcnJheVxuXHRcdFx0YXJncz0gYXJncy5qb2luKCAnJyApLnJlcGxhY2UoIC9eXFxzK3xcXHMrJC9nLCAnJyApLnJlcGxhY2UoIC9cXHMrL2csICcgJyApLnNwbGl0ICcgJ1xuXHRcdGVsc2UgaWYgdHlwZXMuaXNBcnJheSBhcmdzWyAwIF1cblx0XHRcdGFyZ3M9IGFyZ3NbIDAgXVxuXHRyZXR1cm4gYXJnc1xuXG5cblxuXG5UeXBlcy50eXBlT2Y9IFR5cGVzLnR5cGVvZj0gKCB2YWx1ZSApIC0+XG5cdGZvciBuYW1lLCBwcmVkaWNhdGUgb2YgVFlQRVNcblx0XHRyZXR1cm4gbmFtZSBpZiBwcmVkaWNhdGUodmFsdWUpIGlzIHRydWVcblxuXG5cblxuVHlwZXMuZW51bT0gVHlwZXMuZW51bWVyYXRlPSAoIGl0ZW1zLCBvZmZzZXQgKSAtPlxuXHRvZmZzZXRcdD0gdHlwZXMuZm9yY2VOdW1iZXIgb2Zmc2V0LCAwXG5cdF9lbnVtXHRcdD0gY3JlYXRlRW51bSgpXG5cblx0aWYgdHlwZXMubm90QXJyYXkgaXRlbXNcblx0XHRsb2cgXCIje0VOVU1fRVJSX1BSRUZJWH0gaW52YWxpZCBvciBtaXNzaW5nIGVudW1lcmF0aW9uIGFycmF5XCJcblx0XHRyZXR1cm4gX2VudW1cblxuXHRmb3IgaXRlbSwgaW5kZXggaW4gaXRlbXNcblx0XHRpZiB0eXBlcy5pc1N0cmluZyBpdGVtIHRoZW4gX2VudW1bIGl0ZW0gXT0gKGluZGV4KyBvZmZzZXQpXG5cdFx0ZWxzZSBsb2cgXCIje0VOVU1fRVJSX1BSRUZJWH0gaWdub3JlZCBub24tc3RyaW5nIGl0ZW0gdGhhdCB3YXMgZm91bmQgaW4gZW51bWVyYXRpb24gYXJyYXlcIlxuXG5cdHR5cGVzLmZvcmNlRnVuY3Rpb24oIE9iamVjdC5mcmVlemUgKSBfZW51bVxuXHRyZXR1cm4gX2VudW1cblxuXG5cblxuaWYgZGVmaW5lPyBhbmQgKCBGVU5DVElPTiBpcyB0eXBlb2YgZGVmaW5lICkgYW5kIGRlZmluZS5hbWRcblx0ZGVmaW5lICd0eXBlcycsIFtdLCAtPiBUeXBlc1xuXG5pZiB0eXBlb2YgbW9kdWxlIGlzbnQgVU5ERUZJTkVEXG5cdG1vZHVsZS5leHBvcnRzPSBUeXBlc1xuXG5pZiB0eXBlb2Ygd2luZG93IGlzbnQgVU5ERUZJTkVEXG5cdHdpbmRvdy5UeXBlcz0gVHlwZXMiXSwic291cmNlUm9vdCI6IiJ9
//# sourceURL=/home/phaze/devel/phazelift/types.js/types.coffee