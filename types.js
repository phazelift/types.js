// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var LITERALS, TYPES, Types, breakIfEqual, createForce, instanceOf, log, logPrefix, testValues, typeOf, types,
    slice = [].slice;

  log = function() {};

  logPrefix = 'types.js - force';

  instanceOf = function(type, value) {
    return value instanceof type;
  };

  typeOf = function(value, type) {
    if (type == null) {
      type = 'object';
    }
    return typeof value === type;
  };

  LITERALS = {
    'Boolean': false,
    'String': '',
    'Object': {},
    'Array': [],
    'Function': function() {},
    'Number': (function() {
      var number;
      number = new Number;
      number["void"] = true;
      return number;
    })(),
    'RegExp': new RegExp
  };

  TYPES = {
    'Undefined': function(value) {
      return value === void 0;
    },
    'Null': function(value) {
      return value === null;
    },
    'Function': function(value) {
      return typeOf(value, 'function');
    },
    'Boolean': function(value) {
      return typeOf(value, 'boolean');
    },
    'String': function(value) {
      return typeOf(value, 'string');
    },
    'Array': function(value) {
      return typeOf(value) && instanceOf(Array, value);
    },
    'RegExp': function(value) {
      return typeOf(value) && instanceOf(RegExp, value);
    },
    'Date': function(value) {
      return typeOf(value) && instanceOf(Date, value);
    },
    'Number': function(value) {
      return typeOf(value, 'number') && (value === value) || (typeOf(value) && instanceOf(Number, value));
    },
    'Object': function(value) {
      return typeOf(value) && (value !== null) && !instanceOf(Boolean, value) && !instanceOf(Number, value) && !instanceOf(Array, value) && !instanceOf(RegExp, value) && !instanceOf(Date, value);
    },
    'NaN': function(value) {
      return typeOf(value, 'number') && (value !== value);
    },
    'Defined': function(value) {
      return value !== void 0;
    }
  };

  TYPES.StringOrNumber = function(value) {
    return TYPES.String(value) || TYPES.Number(value);
  };

  Types = types = {
    parseIntBase: 10,
    logForce: function(logger) {
      if (types.isFunction(logger)) {
        return log = logger;
      }
      if (types.isObject(console)) {
        return log = types.forceFunction(console.log);
      }
    }
  };

  createForce = function(type) {
    var convertType;
    convertType = function(value) {
      switch (type) {
        case 'Number':
          if ((types.isNumber(value = parseInt(value, types.parseIntBase))) && !value["void"]) {
            return value;
          }
          break;
        case 'String':
          if (types.isStringOrNumber(value)) {
            return value + '';
          }
          break;
        default:
          if (Types['is' + type](value)) {
            return value;
          }
      }
    };
    return function(value, replacement) {
      var replacementType, valueType;
      valueType = types["typeof"](value);
      if ((value != null) && void 0 !== (value = convertType(value))) {
        return value;
      }
      log(logPrefix + type + ': invalid first argument with type: \'' + valueType + '\'');
      if (types.isDefined(replacement)) {
        replacementType = types["typeof"](replacement);
        if ((replacement != null) && void 0 !== (replacement = convertType(replacement))) {
          return replacement;
        }
        log(logPrefix + type + ': invalid second argument with type: \'' + replacementType + '\'');
      }
      log(logPrefix + type + ': forcing return value to type ' + type);
      return LITERALS[type];
    };
  };

  testValues = function(predicate, breakState, values) {
    var i, len, value;
    if (values == null) {
      values = [];
    }
    if (values.length < 1) {
      return predicate === TYPES.Undefined;
    }
    for (i = 0, len = values.length; i < len; i++) {
      value = values[i];
      if (predicate(value) === breakState) {
        return breakState;
      }
    }
    return !breakState;
  };

  breakIfEqual = true;

  (function() {
    var name, predicate, results;
    results = [];
    for (name in TYPES) {
      predicate = TYPES[name];
      results.push((function(name, predicate) {
        Types['is' + name] = predicate;
        Types['not' + name] = function(value) {
          return !predicate(value);
        };
        Types['has' + name] = function() {
          return testValues(predicate, breakIfEqual, arguments);
        };
        Types['all' + name] = function() {
          return testValues(predicate, !breakIfEqual, arguments);
        };
        if (name in LITERALS) {
          Types['force' + name] = createForce(name);
        }
        return Types['getFirst' + name] = function() {
          var i, len, value, values;
          values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          for (i = 0, len = values.length; i < len; i++) {
            value = values[i];
            if (Types['is' + name](value)) {
              return value;
            }
          }
        };
      })(name, predicate));
    }
    return results;
  })();

  Types.intoArray = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (args.length < 2) {
      if (types.isString(args[0])) {
        args = args.join('').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ').split(' ');
      } else if (types.isArray(args[0])) {
        args = args[0];
      }
    }
    return args;
  };

  Types["typeof"] = function(value) {
    var name, predicate;
    for (name in TYPES) {
      predicate = TYPES[name];
      if (predicate(value) === true) {
        return name.toLowerCase();
      }
    }
  };

  if ((typeof define !== "undefined" && define !== null) && ('function' === typeof define) && define.amd) {
    define('types', [], function() {
      return Types;
    });
  }

  if (typeof module !== 'undefined') {
    module.exports = Types;
  }

  if (typeof window !== 'undefined') {
    window.Types = Types;
  }

}).call(this);
