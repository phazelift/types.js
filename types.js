"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// Generated by CoffeeScript 2.7.0
(function () {
  var _LITERALS, _TYPES;
  //	types.js - A tiny and fast dynamic type checker/enforcer library

  // MIT License

  // Copyright (c) 2014 Dennis Raymondo van der Sluis

  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:

  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.

  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.

  // heavily refactored to reduce size while optimizing for speed, at the cost of some readability..
  var ARRAY, BOOLEAN, BREAK_IF_EQUAL, DATE, DEFINED, ENUM, ENUM_ERR_PREFIX, ENUM_ID, FORCE_MSG_PREFIX, FUNCTION, LITERALS, LOGGING_DISABLED, LOGGING_ENABLED, MODULE_NAME, NAN, NULL, NUMBER, OBJECT, REGEXP, STRING, SYMBOL, TYPES, Types, UNDEFINED, createEnum, createForce, instanceOf, log, _logForce, testHasAndAll, typeOf, types, upFirst;
  MODULE_NAME = 'types.js';
  ENUM_ID = '_ENUM_';
  FORCE_MSG_PREFIX = "".concat(MODULE_NAME, " - force");
  ENUM_ERR_PREFIX = "".concat(MODULE_NAME, " - enum: ERROR,");
  LOGGING_DISABLED = "".concat(MODULE_NAME, " - all logging disabled by user");
  LOGGING_ENABLED = "".concat(MODULE_NAME, " - logging re-enabled by user");
  ARRAY = 'array';
  BOOLEAN = 'boolean';
  DATE = 'date';
  DEFINED = 'defined';
  ENUM = 'enum';
  FUNCTION = 'function';
  NAN = 'nan';
  NULL = 'null';
  NUMBER = 'number';
  OBJECT = 'object';
  REGEXP = 'regexp';
  STRING = 'string';
  SYMBOL = 'symbol';
  UNDEFINED = 'undefined';
  LITERALS = (_LITERALS = {}, _defineProperty(_LITERALS, BOOLEAN, false), _defineProperty(_LITERALS, STRING, ''), _defineProperty(_LITERALS, OBJECT, {}), _defineProperty(_LITERALS, ARRAY, []), _defineProperty(_LITERALS, FUNCTION, function () {}), _defineProperty(_LITERALS, NUMBER, function () {
    var number;
    number = new Number();
    number["void"] = true;
    return number;
  }()), _defineProperty(_LITERALS, REGEXP, new RegExp()), _defineProperty(_LITERALS, DATE, new Date()), _LITERALS);
  log = function log() {
    if (Types.logging) {
      var _console;
      return (_console = console).log.apply(_console, arguments);
    }
  };
  _logForce = function logForce() {};

  // an unsafe internal for making the first character of a type id uppercase
  upFirst = function upFirst(str) {
    if (str === 'regexp') {
      return 'RegExp';
    } else {
      return str[0].toUpperCase() + str.slice(1);
    }
  };
  instanceOf = function instanceOf(type, value) {
    return value instanceof type;
  };

  // type defaults to object, for internal can do, saves for a few bytes..
  typeOf = function typeOf(value) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : OBJECT;
    return _typeof(value) === type;
  };
  createEnum = function createEnum() {
    var _enum;
    _enum = {};
    Object.defineProperty(_enum, ENUM_ID, {
      configurable: false,
      enumerable: false,
      value: true,
      writable: false
    });
    return _enum;
  };

  // all definitions that will be used for the is[type], not[type], etc.. tests
  TYPES = (_TYPES = {}, _defineProperty(_TYPES, UNDEFINED, function (value) {
    return value === void 0;
  }), _defineProperty(_TYPES, NULL, function (value) {
    return value === null;
  }), _defineProperty(_TYPES, FUNCTION, function (value) {
    return typeOf(value, FUNCTION);
  }), _defineProperty(_TYPES, BOOLEAN, function (value) {
    return typeOf(value, BOOLEAN);
  }), _defineProperty(_TYPES, STRING, function (value) {
    return typeOf(value, STRING);
  }), _defineProperty(_TYPES, ARRAY, function (value) {
    return typeOf(value) && instanceOf(Array, value);
  }), _defineProperty(_TYPES, REGEXP, function (value) {
    return typeOf(value) && instanceOf(RegExp, value);
  }), _defineProperty(_TYPES, DATE, function (value) {
    return typeOf(value) && instanceOf(Date, value);
  }), _defineProperty(_TYPES, NUMBER, function (value) {
    return typeOf(value, NUMBER) && value === value || typeOf(value) && instanceOf(Number, value);
  }), _defineProperty(_TYPES, ENUM, function (value) {
    return Types.forceObject(value).hasOwnProperty(ENUM_ID);
  }), _defineProperty(_TYPES, OBJECT, function (value) {
    return typeOf(value) && value !== null && !instanceOf(Boolean, value) && !instanceOf(Number, value) && !instanceOf(Array, value) && !instanceOf(RegExp, value) && !instanceOf(Date, value);
  }), _defineProperty(_TYPES, SYMBOL, function (value) {
    return typeOf(value, SYMBOL);
  }), _defineProperty(_TYPES, NAN, function (value) {
    return typeOf(value, NUMBER) && value !== value;
  }), _defineProperty(_TYPES, DEFINED, function (value) {
    return value !== void 0;
  }), _TYPES);
  TYPES.StringOrNumber = function (value) {
    return TYPES[STRING](value) || TYPES[NUMBER](value);
  };

  // define the main object that this module returns
  Types = types = {
    // used by forceNumber to set the Radix, defaults to decimals
    parseIntBase: 10,
    autoConvert: true,
    logging: true,
    disableLogging: function disableLogging() {
      Types.logging = false;
      return console.log(LOGGING_DISABLED);
    },
    enableLogging: function enableLogging() {
      Types.logging = true;
      return console.log(LOGGING_ENABLED);
    },
    logForce: function logForce(externalLog) {
      return _logForce = function _logForce(errLevel, expectedType, encounteredType) {
        var msg;
        if (Types.isFunction(externalLog)) {
          return externalLog(errLevel, expectedType, encounteredType);
        } else {
          msg = expectedType;
          switch (errLevel) {
            case 1:
              msg += ": initial value is not of type " + expectedType;
              break;
            case 2:
              msg += ": optional value is not of type " + expectedType;
              break;
            case 3:
              msg += ": no valid type found, returning a type " + expectedType + " literal";
          }
          return log(FORCE_MSG_PREFIX + msg);
        }
      };
    }
  };

  // factory that creates all Types.force[type] variations
  createForce = function createForce(type) {
    var Type, test;
    Type = upFirst(type);
    // convert value in case initial Type test failed. failed conversion returns undefined
    test = function test(value) {
      if (types.autoConvert) {
        switch (type) {
          case NUMBER:
            if (types.isString(value)) {
              value = parseInt(value, types.parseIntBase);
            }
            break;
          case STRING:
            if (types.isNumber(value)) {
              value += '';
            }
        }
      }
      if (Types['is' + Type](value)) {
        return value;
      }
    };
    // the forctType method, returns the Type's literal or defaultValue if both value and replacement are not compatible
    return function (value, replacement) {
      var okValue, replacementType;
      if (value != null && void 0 !== (okValue = test(value))) {
        return okValue;
      }
      _logForce(1, Type, value);
      if (types.isDefined(replacement)) {
        replacementType = types["typeof"](replacement);
        if (replacement != null && void 0 !== (replacement = test(replacement))) {
          return replacement;
        } else {
          _logForce(2, Type, value);
        }
      }
      _logForce(3, Type, value);
      return LITERALS[type];
    };
  };

  // test multiple values(arguments) for a given predicate. returns breakState if predicate is breakState for some value
  // when no break occured, ! breakState will be returned.
  testHasAndAll = function testHasAndAll(predicate, breakState) {
    var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var i, len, value;
    if (values.length < 1) {
      // testing 'has' or 'all' for 'undefined' should return true on calls without arguments
      return predicate === TYPES[UNDEFINED];
    }
    for (i = 0, len = values.length; i < len; i++) {
      value = values[i];
      if (predicate(value) === breakState) {
        return breakState;
      }
    }
    return !breakState;
  };

  // generate all the is/not/has/all/force Types
  BREAK_IF_EQUAL = true;
  (function () {
    var predicate, results, type;
    results = [];
    for (type in TYPES) {
      predicate = TYPES[type];
      results.push(function (type, predicate) {
        var Type;
        Type = function () {
          switch (type) {
            case NAN:
              return 'NaN';
            case REGEXP:
              return 'RegExp';
            default:
              return upFirst(type);
          }
        }();
        Types['is' + Type] = predicate;
        Types['not' + Type] = function (value) {
          return !predicate(value);
        };
        Types['has' + Type] = function () {
          return testHasAndAll(predicate, BREAK_IF_EQUAL, arguments);
        };
        Types['all' + Type] = function () {
          return testHasAndAll(predicate, !BREAK_IF_EQUAL, arguments);
        };
        // create only forceType of types found in LITERALS
        if (type in LITERALS) {
          Types['force' + Type] = createForce(type);
        }
        return Types['getFirst' + Type] = function () {
          var i, len, value;
          for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
            values[_key] = arguments[_key];
          }
          for (i = 0, len = values.length; i < len; i++) {
            value = values[i];
            if (Types['is' + Type](value)) {
              return value;
            }
          }
        };
      }(type, predicate));
    }
    return results;
  })();
  Types.intoArray = function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (args.length < 2) {
      if (types.isString(args[0])) {
        // to string, trim, limit to one consecutive space, back to array
        args = args.join('').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ').split(' ');
      } else if (types.isArray(args[0])) {
        args = args[0];
      }
    }
    return args;
  };
  Types.typeOf = Types["typeof"] = function (value) {
    var name, predicate;
    for (name in TYPES) {
      predicate = TYPES[name];
      if (predicate(value) === true) {
        return name;
      }
    }
  };
  Types["enum"] = Types.enumerate = function (items, offset) {
    var _enum, i, index, item, len;
    offset = types.forceNumber(offset, 0);
    _enum = createEnum();
    if (types.notArray(items)) {
      log("".concat(ENUM_ERR_PREFIX, " invalid or missing enumeration array"));
      return _enum;
    }
    for (index = i = 0, len = items.length; i < len; index = ++i) {
      item = items[index];
      if (types.isString(item)) {
        _enum[item] = index + offset;
      } else {
        log("".concat(ENUM_ERR_PREFIX, " ignored non-string item that was found in enumeration array"));
      }
    }
    types.forceFunction(Object.freeze)(_enum);
    return _enum;
  };
  if (typeof define !== "undefined" && define !== null && FUNCTION === (typeof define === "undefined" ? "undefined" : _typeof(define)) && define.amd) {
    define('types', [], function () {
      return Types;
    });
  }
  if ((typeof module === "undefined" ? "undefined" : _typeof(module)) !== UNDEFINED) {
    module.exports = Types;
  }
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== UNDEFINED) {
    window.Types = Types;
  }
}).call(void 0);